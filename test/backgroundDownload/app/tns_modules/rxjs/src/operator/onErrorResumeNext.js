"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var FromObservable_1 = require("../observable/FromObservable");
var isArray_1 = require("../util/isArray");
var OuterSubscriber_1 = require("../OuterSubscriber");
var subscribeToResult_1 = require("../util/subscribeToResult");
/* tslint:enable:max-line-length */
/**
 * When any of the provided Observable emits an complete or error notification, it immediately subscribes to the next one
 * that was passed.
 *
 * <span class="informal">Execute series of Observables no matter what, even if it means swallowing errors.</span>
 *
 * <img src="./img/onErrorResumeNext.png" width="100%">
 *
 * `onErrorResumeNext` is an operator that accepts a series of Observables, provided either directly as
 * arguments or as an array. If no single Observable is provided, returned Observable will simply behave the same
 * as the source.
 *
 * `onErrorResumeNext` returns an Observable that starts by subscribing and re-emitting values from the source Observable.
 * When its stream of values ends - no matter if Observable completed or emitted an error - `onErrorResumeNext`
 * will subscribe to the first Observable that was passed as an argument to the method. It will start re-emitting
 * its values as well and - again - when that stream ends, `onErrorResumeNext` will proceed to subscribing yet another
 * Observable in provided series, no matter if previous Observable completed or ended with an error. This will
 * be happening until there is no more Observables left in the series, at which point returned Observable will
 * complete - even if the last subscribed stream ended with an error.
 *
 * `onErrorResumeNext` can be therefore though of as version of {@link concat} operator, which is more permissive
 * when it comes to the errors emitted by its input Observables. While `concat` subscribes to the next Observable
 * in series only if previous one successfully completed, `onErrorResumeNext` subscribes even if it ended with
 * an error.
 *
 * Note that you do not get any access to errors emitted by the Observables. In particular do not
 * expect these errors to appear in error callback passed to {@link subscribe}. If you want to take
 * specific actions based on what error was emitted by an Observable, you should try out {@link catch} instead.
 *
 *
 * @example <caption>Subscribe to the next Observable after map fails</caption>
 * Rx.Observable.of(1, 2, 3, 0)
 *   .map(x => {
 *       if (x === 0) { throw Error(); }
         return 10 / x;
 *   })
 *   .onErrorResumeNext(Rx.Observable.of(1, 2, 3))
 *   .subscribe(
 *     val => console.log(val),
 *     err => console.log(err),          // Will never be called.
 *     () => console.log('that\'s it!')
 *   );
 *
 * // Logs:
 * // 10
 * // 5
 * // 3.3333333333333335
 * // 1
 * // 2
 * // 3
 * // "that's it!"
 *
 * @see {@link concat}
 * @see {@link catch}
 *
 * @param {...ObservableInput} observables Observables passed either directly or as an array.
 * @return {Observable} An Observable that emits values from source Observable, but - if it errors - subscribes
 * to the next passed Observable and so on, until it completes or runs out of Observables.
 * @method onErrorResumeNext
 * @owner Observable
 */
function onErrorResumeNext() {
    var nextSources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        nextSources[_i] = arguments[_i];
    }
    if (nextSources.length === 1 && isArray_1.isArray(nextSources[0])) {
        nextSources = nextSources[0];
    }
    return this.lift(new OnErrorResumeNextOperator(nextSources));
}
exports.onErrorResumeNext = onErrorResumeNext;
/* tslint:enable:max-line-length */
function onErrorResumeNextStatic() {
    var nextSources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        nextSources[_i] = arguments[_i];
    }
    var source = null;
    if (nextSources.length === 1 && isArray_1.isArray(nextSources[0])) {
        nextSources = nextSources[0];
    }
    source = nextSources.shift();
    return new FromObservable_1.FromObservable(source, null).lift(new OnErrorResumeNextOperator(nextSources));
}
exports.onErrorResumeNextStatic = onErrorResumeNextStatic;
var OnErrorResumeNextOperator = (function () {
    function OnErrorResumeNextOperator(nextSources) {
        this.nextSources = nextSources;
    }
    OnErrorResumeNextOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new OnErrorResumeNextSubscriber(subscriber, this.nextSources));
    };
    return OnErrorResumeNextOperator;
}());
var OnErrorResumeNextSubscriber = (function (_super) {
    __extends(OnErrorResumeNextSubscriber, _super);
    function OnErrorResumeNextSubscriber(destination, nextSources) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.nextSources = nextSources;
        return _this;
    }
    OnErrorResumeNextSubscriber.prototype.notifyError = function (error, innerSub) {
        this.subscribeToNextSource();
    };
    OnErrorResumeNextSubscriber.prototype.notifyComplete = function (innerSub) {
        this.subscribeToNextSource();
    };
    OnErrorResumeNextSubscriber.prototype._error = function (err) {
        this.subscribeToNextSource();
    };
    OnErrorResumeNextSubscriber.prototype._complete = function () {
        this.subscribeToNextSource();
    };
    OnErrorResumeNextSubscriber.prototype.subscribeToNextSource = function () {
        var next = this.nextSources.shift();
        if (next) {
            this.add(subscribeToResult_1.subscribeToResult(this, next));
        }
        else {
            this.destination.complete();
        }
    };
    return OnErrorResumeNextSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib25FcnJvclJlc3VtZU5leHQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJvbkVycm9yUmVzdW1lTmV4dC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUNBLCtEQUE4RDtBQUc5RCwyQ0FBMEM7QUFDMUMsc0RBQXFEO0FBRXJELCtEQUE4RDtBQVU5RCxtQ0FBbUM7QUFFbkM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQTRERztBQUVIO0lBQTZELHFCQUV5QjtTQUZ6QixVQUV5QixFQUZ6QixxQkFFeUIsRUFGekIsSUFFeUI7UUFGekIsZ0NBRXlCOztJQUNwRixFQUFFLENBQUMsQ0FBQyxXQUFXLENBQUMsTUFBTSxLQUFLLENBQUMsSUFBSSxpQkFBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN4RCxXQUFXLEdBQTJCLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN2RCxDQUFDO0lBRUQsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSx5QkFBeUIsQ0FBTyxXQUFXLENBQUMsQ0FBQyxDQUFDO0FBQ3JFLENBQUM7QUFSRCw4Q0FRQztBQVdELG1DQUFtQztBQUVuQztJQUE4QyxxQkFFK0M7U0FGL0MsVUFFK0MsRUFGL0MscUJBRStDLEVBRi9DLElBRStDO1FBRi9DLGdDQUUrQzs7SUFDM0YsSUFBSSxNQUFNLEdBQXlCLElBQUksQ0FBQztJQUV4QyxFQUFFLENBQUMsQ0FBQyxXQUFXLENBQUMsTUFBTSxLQUFLLENBQUMsSUFBSSxpQkFBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN4RCxXQUFXLEdBQWdDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM1RCxDQUFDO0lBQ0QsTUFBTSxHQUFHLFdBQVcsQ0FBQyxLQUFLLEVBQUUsQ0FBQztJQUU3QixNQUFNLENBQUMsSUFBSSwrQkFBYyxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSx5QkFBeUIsQ0FBTyxXQUFXLENBQUMsQ0FBQyxDQUFDO0FBQ2pHLENBQUM7QUFYRCwwREFXQztBQUVEO0lBQ0UsbUNBQW9CLFdBQXdDO1FBQXhDLGdCQUFXLEdBQVgsV0FBVyxDQUE2QjtJQUM1RCxDQUFDO0lBRUQsd0NBQUksR0FBSixVQUFLLFVBQXlCLEVBQUUsTUFBVztRQUN6QyxNQUFNLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxJQUFJLDJCQUEyQixDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQztJQUN6RixDQUFDO0lBQ0gsZ0NBQUM7QUFBRCxDQUFDLEFBUEQsSUFPQztBQUVEO0lBQWdELCtDQUFxQjtJQUNuRSxxQ0FBc0IsV0FBMEIsRUFDNUIsV0FBd0M7UUFENUQsWUFFRSxrQkFBTSxXQUFXLENBQUMsU0FDbkI7UUFIcUIsaUJBQVcsR0FBWCxXQUFXLENBQWU7UUFDNUIsaUJBQVcsR0FBWCxXQUFXLENBQTZCOztJQUU1RCxDQUFDO0lBRUQsaURBQVcsR0FBWCxVQUFZLEtBQVUsRUFBRSxRQUFpQztRQUN2RCxJQUFJLENBQUMscUJBQXFCLEVBQUUsQ0FBQztJQUMvQixDQUFDO0lBRUQsb0RBQWMsR0FBZCxVQUFlLFFBQWlDO1FBQzlDLElBQUksQ0FBQyxxQkFBcUIsRUFBRSxDQUFDO0lBQy9CLENBQUM7SUFFUyw0Q0FBTSxHQUFoQixVQUFpQixHQUFRO1FBQ3ZCLElBQUksQ0FBQyxxQkFBcUIsRUFBRSxDQUFDO0lBQy9CLENBQUM7SUFFUywrQ0FBUyxHQUFuQjtRQUNFLElBQUksQ0FBQyxxQkFBcUIsRUFBRSxDQUFDO0lBQy9CLENBQUM7SUFFTywyREFBcUIsR0FBN0I7UUFDRSxJQUFNLElBQUksR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssRUFBRSxDQUFDO1FBQ3RDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7WUFDVCxJQUFJLENBQUMsR0FBRyxDQUFDLHFDQUFpQixDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBQzFDLENBQUM7UUFBQyxJQUFJLENBQUMsQ0FBQztZQUNOLElBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxFQUFFLENBQUM7UUFDOUIsQ0FBQztJQUNILENBQUM7SUFDSCxrQ0FBQztBQUFELENBQUMsQUE5QkQsQ0FBZ0QsaUNBQWUsR0E4QjlEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgT2JzZXJ2YWJsZSwgT2JzZXJ2YWJsZUlucHV0IH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBGcm9tT2JzZXJ2YWJsZSB9IGZyb20gJy4uL29ic2VydmFibGUvRnJvbU9ic2VydmFibGUnO1xuaW1wb3J0IHsgT3BlcmF0b3IgfSBmcm9tICcuLi9PcGVyYXRvcic7XG5pbXBvcnQgeyBTdWJzY3JpYmVyIH0gZnJvbSAnLi4vU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBpc0FycmF5IH0gZnJvbSAnLi4vdXRpbC9pc0FycmF5JztcbmltcG9ydCB7IE91dGVyU3Vic2NyaWJlciB9IGZyb20gJy4uL091dGVyU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBJbm5lclN1YnNjcmliZXIgfSBmcm9tICcuLi9Jbm5lclN1YnNjcmliZXInO1xuaW1wb3J0IHsgc3Vic2NyaWJlVG9SZXN1bHQgfSBmcm9tICcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0JztcblxuLyogdHNsaW50OmRpc2FibGU6bWF4LWxpbmUtbGVuZ3RoICovXG5leHBvcnQgZnVuY3Rpb24gb25FcnJvclJlc3VtZU5leHQ8VCwgUj4odGhpczogT2JzZXJ2YWJsZTxUPiwgdjogT2JzZXJ2YWJsZUlucHV0PFI+KTogT2JzZXJ2YWJsZTxSPjtcbmV4cG9ydCBmdW5jdGlvbiBvbkVycm9yUmVzdW1lTmV4dDxULCBUMiwgVDMsIFI+KHRoaXM6IE9ic2VydmFibGU8VD4sIHYyOiBPYnNlcnZhYmxlSW5wdXQ8VDI+LCB2MzogT2JzZXJ2YWJsZUlucHV0PFQzPik6IE9ic2VydmFibGU8Uj47XG5leHBvcnQgZnVuY3Rpb24gb25FcnJvclJlc3VtZU5leHQ8VCwgVDIsIFQzLCBUNCwgUj4odGhpczogT2JzZXJ2YWJsZTxUPiwgdjI6IE9ic2VydmFibGVJbnB1dDxUMj4sIHYzOiBPYnNlcnZhYmxlSW5wdXQ8VDM+LCB2NDogT2JzZXJ2YWJsZUlucHV0PFQ0Pik6IE9ic2VydmFibGU8Uj47XG5leHBvcnQgZnVuY3Rpb24gb25FcnJvclJlc3VtZU5leHQ8VCwgVDIsIFQzLCBUNCwgVDUsIFI+KHRoaXM6IE9ic2VydmFibGU8VD4sIHYyOiBPYnNlcnZhYmxlSW5wdXQ8VDI+LCB2MzogT2JzZXJ2YWJsZUlucHV0PFQzPiwgdjQ6IE9ic2VydmFibGVJbnB1dDxUND4sIHY1OiBPYnNlcnZhYmxlSW5wdXQ8VDU+KTogT2JzZXJ2YWJsZTxSPjtcbmV4cG9ydCBmdW5jdGlvbiBvbkVycm9yUmVzdW1lTmV4dDxULCBUMiwgVDMsIFQ0LCBUNSwgVDYsIFI+KHRoaXM6IE9ic2VydmFibGU8VD4sIHYyOiBPYnNlcnZhYmxlSW5wdXQ8VDI+LCB2MzogT2JzZXJ2YWJsZUlucHV0PFQzPiwgdjQ6IE9ic2VydmFibGVJbnB1dDxUND4sIHY1OiBPYnNlcnZhYmxlSW5wdXQ8VDU+LCB2NjogT2JzZXJ2YWJsZUlucHV0PFQ2Pik6IE9ic2VydmFibGU8Uj4gO1xuZXhwb3J0IGZ1bmN0aW9uIG9uRXJyb3JSZXN1bWVOZXh0PFQsIFI+KHRoaXM6IE9ic2VydmFibGU8VD4sIC4uLm9ic2VydmFibGVzOiBBcnJheTxPYnNlcnZhYmxlSW5wdXQ8YW55PiB8ICgoLi4udmFsdWVzOiBBcnJheTxhbnk+KSA9PiBSKT4pOiBPYnNlcnZhYmxlPFI+O1xuZXhwb3J0IGZ1bmN0aW9uIG9uRXJyb3JSZXN1bWVOZXh0PFQsIFI+KHRoaXM6IE9ic2VydmFibGU8VD4sIGFycmF5OiBPYnNlcnZhYmxlSW5wdXQ8YW55PltdKTogT2JzZXJ2YWJsZTxSPjtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG5cbi8qKlxuICogV2hlbiBhbnkgb2YgdGhlIHByb3ZpZGVkIE9ic2VydmFibGUgZW1pdHMgYW4gY29tcGxldGUgb3IgZXJyb3Igbm90aWZpY2F0aW9uLCBpdCBpbW1lZGlhdGVseSBzdWJzY3JpYmVzIHRvIHRoZSBuZXh0IG9uZVxuICogdGhhdCB3YXMgcGFzc2VkLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5FeGVjdXRlIHNlcmllcyBvZiBPYnNlcnZhYmxlcyBubyBtYXR0ZXIgd2hhdCwgZXZlbiBpZiBpdCBtZWFucyBzd2FsbG93aW5nIGVycm9ycy48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9vbkVycm9yUmVzdW1lTmV4dC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgb25FcnJvclJlc3VtZU5leHRgIGlzIGFuIG9wZXJhdG9yIHRoYXQgYWNjZXB0cyBhIHNlcmllcyBvZiBPYnNlcnZhYmxlcywgcHJvdmlkZWQgZWl0aGVyIGRpcmVjdGx5IGFzXG4gKiBhcmd1bWVudHMgb3IgYXMgYW4gYXJyYXkuIElmIG5vIHNpbmdsZSBPYnNlcnZhYmxlIGlzIHByb3ZpZGVkLCByZXR1cm5lZCBPYnNlcnZhYmxlIHdpbGwgc2ltcGx5IGJlaGF2ZSB0aGUgc2FtZVxuICogYXMgdGhlIHNvdXJjZS5cbiAqXG4gKiBgb25FcnJvclJlc3VtZU5leHRgIHJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IHN0YXJ0cyBieSBzdWJzY3JpYmluZyBhbmQgcmUtZW1pdHRpbmcgdmFsdWVzIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogV2hlbiBpdHMgc3RyZWFtIG9mIHZhbHVlcyBlbmRzIC0gbm8gbWF0dGVyIGlmIE9ic2VydmFibGUgY29tcGxldGVkIG9yIGVtaXR0ZWQgYW4gZXJyb3IgLSBgb25FcnJvclJlc3VtZU5leHRgXG4gKiB3aWxsIHN1YnNjcmliZSB0byB0aGUgZmlyc3QgT2JzZXJ2YWJsZSB0aGF0IHdhcyBwYXNzZWQgYXMgYW4gYXJndW1lbnQgdG8gdGhlIG1ldGhvZC4gSXQgd2lsbCBzdGFydCByZS1lbWl0dGluZ1xuICogaXRzIHZhbHVlcyBhcyB3ZWxsIGFuZCAtIGFnYWluIC0gd2hlbiB0aGF0IHN0cmVhbSBlbmRzLCBgb25FcnJvclJlc3VtZU5leHRgIHdpbGwgcHJvY2VlZCB0byBzdWJzY3JpYmluZyB5ZXQgYW5vdGhlclxuICogT2JzZXJ2YWJsZSBpbiBwcm92aWRlZCBzZXJpZXMsIG5vIG1hdHRlciBpZiBwcmV2aW91cyBPYnNlcnZhYmxlIGNvbXBsZXRlZCBvciBlbmRlZCB3aXRoIGFuIGVycm9yLiBUaGlzIHdpbGxcbiAqIGJlIGhhcHBlbmluZyB1bnRpbCB0aGVyZSBpcyBubyBtb3JlIE9ic2VydmFibGVzIGxlZnQgaW4gdGhlIHNlcmllcywgYXQgd2hpY2ggcG9pbnQgcmV0dXJuZWQgT2JzZXJ2YWJsZSB3aWxsXG4gKiBjb21wbGV0ZSAtIGV2ZW4gaWYgdGhlIGxhc3Qgc3Vic2NyaWJlZCBzdHJlYW0gZW5kZWQgd2l0aCBhbiBlcnJvci5cbiAqXG4gKiBgb25FcnJvclJlc3VtZU5leHRgIGNhbiBiZSB0aGVyZWZvcmUgdGhvdWdoIG9mIGFzIHZlcnNpb24gb2Yge0BsaW5rIGNvbmNhdH0gb3BlcmF0b3IsIHdoaWNoIGlzIG1vcmUgcGVybWlzc2l2ZVxuICogd2hlbiBpdCBjb21lcyB0byB0aGUgZXJyb3JzIGVtaXR0ZWQgYnkgaXRzIGlucHV0IE9ic2VydmFibGVzLiBXaGlsZSBgY29uY2F0YCBzdWJzY3JpYmVzIHRvIHRoZSBuZXh0IE9ic2VydmFibGVcbiAqIGluIHNlcmllcyBvbmx5IGlmIHByZXZpb3VzIG9uZSBzdWNjZXNzZnVsbHkgY29tcGxldGVkLCBgb25FcnJvclJlc3VtZU5leHRgIHN1YnNjcmliZXMgZXZlbiBpZiBpdCBlbmRlZCB3aXRoXG4gKiBhbiBlcnJvci5cbiAqXG4gKiBOb3RlIHRoYXQgeW91IGRvIG5vdCBnZXQgYW55IGFjY2VzcyB0byBlcnJvcnMgZW1pdHRlZCBieSB0aGUgT2JzZXJ2YWJsZXMuIEluIHBhcnRpY3VsYXIgZG8gbm90XG4gKiBleHBlY3QgdGhlc2UgZXJyb3JzIHRvIGFwcGVhciBpbiBlcnJvciBjYWxsYmFjayBwYXNzZWQgdG8ge0BsaW5rIHN1YnNjcmliZX0uIElmIHlvdSB3YW50IHRvIHRha2VcbiAqIHNwZWNpZmljIGFjdGlvbnMgYmFzZWQgb24gd2hhdCBlcnJvciB3YXMgZW1pdHRlZCBieSBhbiBPYnNlcnZhYmxlLCB5b3Ugc2hvdWxkIHRyeSBvdXQge0BsaW5rIGNhdGNofSBpbnN0ZWFkLlxuICpcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5TdWJzY3JpYmUgdG8gdGhlIG5leHQgT2JzZXJ2YWJsZSBhZnRlciBtYXAgZmFpbHM8L2NhcHRpb24+XG4gKiBSeC5PYnNlcnZhYmxlLm9mKDEsIDIsIDMsIDApXG4gKiAgIC5tYXAoeCA9PiB7XG4gKiAgICAgICBpZiAoeCA9PT0gMCkgeyB0aHJvdyBFcnJvcigpOyB9XG4gICAgICAgICByZXR1cm4gMTAgLyB4O1xuICogICB9KVxuICogICAub25FcnJvclJlc3VtZU5leHQoUnguT2JzZXJ2YWJsZS5vZigxLCAyLCAzKSlcbiAqICAgLnN1YnNjcmliZShcbiAqICAgICB2YWwgPT4gY29uc29sZS5sb2codmFsKSxcbiAqICAgICBlcnIgPT4gY29uc29sZS5sb2coZXJyKSwgICAgICAgICAgLy8gV2lsbCBuZXZlciBiZSBjYWxsZWQuXG4gKiAgICAgKCkgPT4gY29uc29sZS5sb2coJ3RoYXRcXCdzIGl0IScpXG4gKiAgICk7XG4gKlxuICogLy8gTG9nczpcbiAqIC8vIDEwXG4gKiAvLyA1XG4gKiAvLyAzLjMzMzMzMzMzMzMzMzMzMzVcbiAqIC8vIDFcbiAqIC8vIDJcbiAqIC8vIDNcbiAqIC8vIFwidGhhdCdzIGl0IVwiXG4gKlxuICogQHNlZSB7QGxpbmsgY29uY2F0fVxuICogQHNlZSB7QGxpbmsgY2F0Y2h9XG4gKlxuICogQHBhcmFtIHsuLi5PYnNlcnZhYmxlSW5wdXR9IG9ic2VydmFibGVzIE9ic2VydmFibGVzIHBhc3NlZCBlaXRoZXIgZGlyZWN0bHkgb3IgYXMgYW4gYXJyYXkuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdmFsdWVzIGZyb20gc291cmNlIE9ic2VydmFibGUsIGJ1dCAtIGlmIGl0IGVycm9ycyAtIHN1YnNjcmliZXNcbiAqIHRvIHRoZSBuZXh0IHBhc3NlZCBPYnNlcnZhYmxlIGFuZCBzbyBvbiwgdW50aWwgaXQgY29tcGxldGVzIG9yIHJ1bnMgb3V0IG9mIE9ic2VydmFibGVzLlxuICogQG1ldGhvZCBvbkVycm9yUmVzdW1lTmV4dFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gb25FcnJvclJlc3VtZU5leHQ8VCwgUj4odGhpczogT2JzZXJ2YWJsZTxUPiwgLi4ubmV4dFNvdXJjZXM6IEFycmF5PE9ic2VydmFibGVJbnB1dDxhbnk+IHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBcnJheTxPYnNlcnZhYmxlSW5wdXQ8YW55Pj4gfFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoLi4udmFsdWVzOiBBcnJheTxhbnk+KSA9PiBSKT4pOiBPYnNlcnZhYmxlPFI+IHtcbiAgaWYgKG5leHRTb3VyY2VzLmxlbmd0aCA9PT0gMSAmJiBpc0FycmF5KG5leHRTb3VyY2VzWzBdKSkge1xuICAgIG5leHRTb3VyY2VzID0gPEFycmF5PE9ic2VydmFibGU8YW55Pj4+bmV4dFNvdXJjZXNbMF07XG4gIH1cblxuICByZXR1cm4gdGhpcy5saWZ0KG5ldyBPbkVycm9yUmVzdW1lTmV4dE9wZXJhdG9yPFQsIFI+KG5leHRTb3VyY2VzKSk7XG59XG5cbi8qIHRzbGludDpkaXNhYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9uRXJyb3JSZXN1bWVOZXh0U3RhdGljPFI+KHY6IE9ic2VydmFibGVJbnB1dDxSPik6IE9ic2VydmFibGU8Uj47XG5leHBvcnQgZnVuY3Rpb24gb25FcnJvclJlc3VtZU5leHRTdGF0aWM8VDIsIFQzLCBSPih2MjogT2JzZXJ2YWJsZUlucHV0PFQyPiwgdjM6IE9ic2VydmFibGVJbnB1dDxUMz4pOiBPYnNlcnZhYmxlPFI+O1xuZXhwb3J0IGZ1bmN0aW9uIG9uRXJyb3JSZXN1bWVOZXh0U3RhdGljPFQyLCBUMywgVDQsIFI+KHYyOiBPYnNlcnZhYmxlSW5wdXQ8VDI+LCB2MzogT2JzZXJ2YWJsZUlucHV0PFQzPiwgdjQ6IE9ic2VydmFibGVJbnB1dDxUND4pOiBPYnNlcnZhYmxlPFI+O1xuZXhwb3J0IGZ1bmN0aW9uIG9uRXJyb3JSZXN1bWVOZXh0U3RhdGljPFQyLCBUMywgVDQsIFQ1LCBSPih2MjogT2JzZXJ2YWJsZUlucHV0PFQyPiwgdjM6IE9ic2VydmFibGVJbnB1dDxUMz4sIHY0OiBPYnNlcnZhYmxlSW5wdXQ8VDQ+LCB2NTogT2JzZXJ2YWJsZUlucHV0PFQ1Pik6IE9ic2VydmFibGU8Uj47XG5leHBvcnQgZnVuY3Rpb24gb25FcnJvclJlc3VtZU5leHRTdGF0aWM8VDIsIFQzLCBUNCwgVDUsIFQ2LCBSPih2MjogT2JzZXJ2YWJsZUlucHV0PFQyPiwgdjM6IE9ic2VydmFibGVJbnB1dDxUMz4sIHY0OiBPYnNlcnZhYmxlSW5wdXQ8VDQ+LCB2NTogT2JzZXJ2YWJsZUlucHV0PFQ1PiwgdjY6IE9ic2VydmFibGVJbnB1dDxUNj4pOiBPYnNlcnZhYmxlPFI+O1xuXG5leHBvcnQgZnVuY3Rpb24gb25FcnJvclJlc3VtZU5leHRTdGF0aWM8Uj4oLi4ub2JzZXJ2YWJsZXM6IEFycmF5PE9ic2VydmFibGVJbnB1dDxhbnk+IHwgKCguLi52YWx1ZXM6IEFycmF5PGFueT4pID0+IFIpPik6IE9ic2VydmFibGU8Uj47XG5leHBvcnQgZnVuY3Rpb24gb25FcnJvclJlc3VtZU5leHRTdGF0aWM8Uj4oYXJyYXk6IE9ic2VydmFibGVJbnB1dDxhbnk+W10pOiBPYnNlcnZhYmxlPFI+O1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG9uRXJyb3JSZXN1bWVOZXh0U3RhdGljPFQsIFI+KC4uLm5leHRTb3VyY2VzOiBBcnJheTxPYnNlcnZhYmxlSW5wdXQ8YW55PiB8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5PE9ic2VydmFibGVJbnB1dDxhbnk+PiB8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoLi4udmFsdWVzOiBBcnJheTxhbnk+KSA9PiBSKT4pOiBPYnNlcnZhYmxlPFI+IHtcbiAgbGV0IHNvdXJjZTogT2JzZXJ2YWJsZUlucHV0PGFueT4gPSBudWxsO1xuXG4gIGlmIChuZXh0U291cmNlcy5sZW5ndGggPT09IDEgJiYgaXNBcnJheShuZXh0U291cmNlc1swXSkpIHtcbiAgICBuZXh0U291cmNlcyA9IDxBcnJheTxPYnNlcnZhYmxlSW5wdXQ8YW55Pj4+bmV4dFNvdXJjZXNbMF07XG4gIH1cbiAgc291cmNlID0gbmV4dFNvdXJjZXMuc2hpZnQoKTtcblxuICByZXR1cm4gbmV3IEZyb21PYnNlcnZhYmxlKHNvdXJjZSwgbnVsbCkubGlmdChuZXcgT25FcnJvclJlc3VtZU5leHRPcGVyYXRvcjxULCBSPihuZXh0U291cmNlcykpO1xufVxuXG5jbGFzcyBPbkVycm9yUmVzdW1lTmV4dE9wZXJhdG9yPFQsIFI+IGltcGxlbWVudHMgT3BlcmF0b3I8VCwgUj4ge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIG5leHRTb3VyY2VzOiBBcnJheTxPYnNlcnZhYmxlSW5wdXQ8YW55Pj4pIHtcbiAgfVxuXG4gIGNhbGwoc3Vic2NyaWJlcjogU3Vic2NyaWJlcjxSPiwgc291cmNlOiBhbnkpOiBhbnkge1xuICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBPbkVycm9yUmVzdW1lTmV4dFN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5uZXh0U291cmNlcykpO1xuICB9XG59XG5cbmNsYXNzIE9uRXJyb3JSZXN1bWVOZXh0U3Vic2NyaWJlcjxULCBSPiBleHRlbmRzIE91dGVyU3Vic2NyaWJlcjxULCBSPiB7XG4gIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBkZXN0aW5hdGlvbjogU3Vic2NyaWJlcjxUPixcbiAgICAgICAgICAgICAgcHJpdmF0ZSBuZXh0U291cmNlczogQXJyYXk8T2JzZXJ2YWJsZUlucHV0PGFueT4+KSB7XG4gICAgc3VwZXIoZGVzdGluYXRpb24pO1xuICB9XG5cbiAgbm90aWZ5RXJyb3IoZXJyb3I6IGFueSwgaW5uZXJTdWI6IElubmVyU3Vic2NyaWJlcjxULCBhbnk+KTogdm9pZCB7XG4gICAgdGhpcy5zdWJzY3JpYmVUb05leHRTb3VyY2UoKTtcbiAgfVxuXG4gIG5vdGlmeUNvbXBsZXRlKGlubmVyU3ViOiBJbm5lclN1YnNjcmliZXI8VCwgYW55Pik6IHZvaWQge1xuICAgIHRoaXMuc3Vic2NyaWJlVG9OZXh0U291cmNlKCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgX2Vycm9yKGVycjogYW55KTogdm9pZCB7XG4gICAgdGhpcy5zdWJzY3JpYmVUb05leHRTb3VyY2UoKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfY29tcGxldGUoKTogdm9pZCB7XG4gICAgdGhpcy5zdWJzY3JpYmVUb05leHRTb3VyY2UoKTtcbiAgfVxuXG4gIHByaXZhdGUgc3Vic2NyaWJlVG9OZXh0U291cmNlKCk6IHZvaWQge1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLm5leHRTb3VyY2VzLnNoaWZ0KCk7XG4gICAgaWYgKG5leHQpIHtcbiAgICAgIHRoaXMuYWRkKHN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIG5leHQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgIH1cbiAgfVxufVxuIl19